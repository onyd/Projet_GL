\documentclass[12pt, a4paper, one side]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{biblatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\title{Documentation de Conception}
\author{}
\date{}

\begin{document}

    \maketitle

    \begin{center}
        Valentin Laclautre, Anthony Dard, Damien Trouche, Martin Gangand, Basel Darwish Jzaerly
    \end{center}

    \tableofcontents
    \section{Architecture logicielle}
    \subsection{Conception Architectural Etape A}
    Tout le code specifique se situe dans le package deca. Il est constitué de plusieurs fichiers
    permettant de gérer l'analyse lexicale, l'analyse syntaxique et la construction de l'arbre abstrait. Toutes les classes nécessaires sont instanciées dans DecacMain
    pour pouvoir être appelées lors de l'execution dans du programme avec ses options.
    \subsubsection{DecacCompiler}
    On instancie un DecacCompiler pour chaque fichier .deca. La classe contient un attribut \textbf{SymbolTable}, \textbf{EnvironmentType} et \textbf{CompilerOptions}. On spécifie dans cette classe les types primitifs autorisés de façon statique et les nouveaux types seront ajoutés dynamiquement pendant l'exécution.

    \subsubsection{SymbolTable}
    Permet d'assurer l'unicité d'un symbol dans son environement.

    \subsubsection{EnvironmentType}
    C'est un dictionnaire associatif permettant de stocker les \textbf{TypeDefinition} avec leurs noms.

    \subsection{Conception Architectural Etape B}
    \subsection{Conception Architectural Etape C}

    Tout le code spécifique se situe dans le package codegen. Il est constitué de plusieurs fichiers
    permettant de gérer la génération de code. Toutes les classes nécessaires sont instanciées dans DecacCompiler
    pour pouvoir être appelées lors de l'exécution  dans l'arbre.

    \subsubsection{Politique de gestion de pile et de registre}

    A chaque variable créée, on la place dans la pile et dans sa définition, on lui donne son adresse dans la pile.
    Lors de l'initialisation ou de l'affectation d'une variable, ou de n'importe quelle instruction nécessitant le
    calcul d'une expression, celui-ci est enregistré sur le registre R1. Bien sur lors du calcul, si c'est nécessaire,
    d'autres registres sont utilisé mais le résultat final est sur R1.

    \subsubsection{RegisterManager}

    Cette classe permet de gérer les registres. Elle prends en attributs le nombres de registres utilisés
    (ceux données en paramètres par la commande -r ou 16 sinon). Elle possède aussi un tableau de boolean
    en attributs. Chaque indice de ce tableau correspond à la valeur d'un registre. La valeur du tableau
    à cette indice est à vrai si le registre est utilisé et faux sinon. Cette classe possède aussi des
    méthodes permettant de renvoyer un registre inutilisé ou d'en libérer un.

    \subsubsection{RegisterAllocator}

    Cette classe permet d'allouer des registres créés de manière virtuelle.
    Cette classe est utilisé lors des opérations arithmétiques et peut être
    très utiles et améliorables pour les développeurs souhaitant travailler
    sur ce projet. En effet dans le programme, lorsque l'on veut utiliser
    des registres, il suffira de créer un registre virtuel avec la classe
    \textit{VirtualRegister}, puis de l'ajouter dans le Set de registres
    virtuelles de \textit{RegisterAllocator}. Ensuite à l'aide d'une méthode
    de cette classe, tout les registres virtuelles créés vont être alloué
    dans de vrai registres. S'il n'y a plus de place, les registres déjà utilisés sont sauvegardés dans la pile.
    Lors de la désallocation, les valeurs étant éventuellement stockées dans la
    pile suite à l'allocation sont remis à leurs registres d'origine.

    \subsubsection{Stack}

    Cette classe possède un attributs donnant la hauteur de la pile (par rapport à GB). Elle possède aussi
    de nombreuses méthodes permettant de mettre la valeur d'un registre au sommet de la pile, ou à un
    endroit précis de la pile. Elle possède aussi d'autres méthodes permettant de récupérer une variable
    se situant à une adresse précise dans la pile.

    \subsubsection{LabelManager}

    Cette classe permet de créer et de renvoyer des label uniques à partir d'un nom. Elle utilise pour cela un HasMap
    qui a un nom de label associe un compteur correspondant au nombre de fois que ce nom de label est utilisé. Cela
    permet de s'assurer que tout les labels sont uniques. Elle possède également des méthodes permettant de donner le nom d'étiquette pour pour la création de méthodes.

    \subsubsection{Utils}

    Cette classe regroupe des méthodes statiques utilisées à de nombreux endroits permettant la génération
    de code. Elle permet entre autre de renvoyer un Immediat d'après son type. Elle permet aussi de renvoyer tout
    le code correspondant à la gestion d'erreur qui appelé à la fin du codeGen du programme.

    \subsubsection{Propagation du code - Les fonctions codeGen}

    A chaque action devant être réalisé, il existe une fonction codeGen spécifique appelant récursivement dans l'arbre
    d'autres fonction codeGen. La première fonction appelé est codeGenProgram qui se propage à la génération de classe
    et du programme principale. Il est interressant de revenir sur quelque fonction codeGen importantes qui sont réutilisés
    de nombreuses fois.

    \medskip
    \textbf{\underline{codeGenExrOnRegister :}}

    Cette méthode est la plus importante de l'étape C. Elle est redéfinie dans
    toutes les classes correspondant à une expression. Elle permet de charger
    la valeur de l'expression qui l'appel dans le registre donné en paramètre.
    Elle est définie simplement dans les littéral ou les identifiant par
    exemple, puisque l'on peut charger directement la valeur dans le registre.
    Elle simplifie grandement le calcul d'expressions plus complexes comme
    les opérations arithmétiques ou les calculs booléens par exemple. Le fonctionnement
    des calculs de ces deux opérations seront décrites plus loin. La méthode
    codeGenExprOnR1 est aussi définie. Elle fait directement appel à la méthode
    codeGenExrOnRegister, mais avec en paramètre le registre R1. Cette méthode
    est définie car il est régulièrement nécessaires de charger une expression
    sur le registre R1.

    \medskip
    \textbf{\underline{codeGenPrint :}}

    Cette méthode est permet l'affichage d'une expression. Elle est par exemple
    utilisée dans la classe \textit{StringLitteral} afin d'appeler l'instruction d'affichage IMA pour une chaine de caractères. Elle appelé à chaque intruction de demandant l'affichage sur la sortie standart. Elle est généralisé dans \textit{AbstractExpr} et est redéfnie dans les cas particuliers.Elle est généralisée de la manière suivante : on charge l'
    expression à afficher dans le registre R1 avec codeGenExprOnR1, puis
    on vérifie son type (int ou float) et on appel l'instruction IMA correspondante.

    \medskip
    \textbf{\underline{codeGenInst:}}

    Cette méthode est appelé pour chaque instruction. Elle est généralisé dans
    \textit{AbstractExpr} de la manière suivante : elle fait simplement appel
    à la méthode codeGenExprOnR1, qui est redéfinie spécifiquement pour chaque
    tokens, comme cela a été expliqué précédemment. Pour les cas spécifiques, elle est redéfinie.

    \section{Chemin de l'exécution du compilateur}
    \subsection{Etape A}

    \subsubsection{DecacMain}
    Le point d'entrée du compilateur est la méthode main de la classe \textbf {DecacMain}. Le main commence par récupérer les options de la commande decac. La classe responsable de ce traitement est \textbf{CompilerOptions}. Les arguments de la commande decac sont parsés et les variables booléennes correspondantes aux options seront à mises à true. Nous pouvons avoir les états de ces Booléens en appelant la méthode getX de la classe CompilerOptions avec X est le nom du booléen.
    \\
    Si l'option de compilation {\textcolor{red}{ en parallèle est activée, plusieurs instances de \textbf{DecacCompiler} seront initialisées en parallèle et chaque instance traite un fichier deca source.}}
    Sinon, une instance du compilateur \textbf{DecacCompiler} sera initialisée de façon séquentielle pour chaque fichier deca avec en paramètres les options et un fichier source.

    \subsubsection{DecacCompiler} C'est la classe cœur du compilateur. Elle contient la méthode \textbf{doCompile} qui réalise la compilation. Dans cette méthode, la racine de l'arbre abstrait du programme \textbf{AbstractProgram} est initialisée. L'initialisation est fait grâce à la méthode \textbf{doLexingAndParsing} qui retourne un AbstractProgram. Cette méthode utilise une instance de la classe \textbf{DecaLexer} qui est présentée par la suite et qui a pour rôle de faire l'analyseur lexicale qui consiste à reconnaître les mots du langage (dits aussi Jetons ou Tokens) . Cette méthode utilise aussi une instance de \textbf{CommonTokenStream} pour stocker les
    jetons. Cette classe appartient au framework \textbf{ANTLR}. Ensuite une instance de la classe \textbf{DecaParser} est déclarée pour faire l'analyse syntaxique. A la fin de cette méthode, l'\textbf{Etape A} est terminé et l'arbre abstrait (une instance de \textbf{AbstractProgram}) est obtenue.

    \subsubsection{DecaLexer} Cette classe est générée automatiquement par le framework ANTLR. Elle a pour role de transformer le programme deca en mots (jetons). Pour configurer ANTLER à accepter le code lexicalement valide, on spécifie les règles lexicales dans \textbf{./src/main/antlr4/fr/ensimag/deca/syntax/DecaLexer.g4}.

    \subsubsection{DecaParser} Cette classe est générée automatiquement par le framework ANTLR. Elle a pour role de déterminer si une suite de mots est une phrase du langage, c'est à dire correspondant à un programme deca syntaxiquement correct. Pour ANTLER il faut définir les grammaires du langage dans \textbf{./src/main/antlr4/fr/ensimag/deca/syntax/DecaParser.g4}.
    \subsubsection{AbstractProgram} Cette classe est dérivée de la classe \textbf{Tree}.

    \subsubsection{Tree} représente le point d'entrée pour la vérification contextuelle et la génération du code.

    \subsection{Etape B}
    Le but de l'étape B est de réaliser des vérifications contextuelles et modifier et décorer l'arbre abstrait du programme pour préparer l'étape C.
    \\
    La vérification déclenchée par la méthode verifyProgram se propage dans tout l'arbre en passant par la classe \textbf{Main}. Dans cette classe les vérifications se passent pour une instance de la classe \textbf{EnvironmentExp} et les listes de \textbf{ListDeclVar} (les déclarations de variables) et \textbf{ListInst} (les déclarations des instructions)

    \subsection{Etape C}
    Cette étape consiste à générer le code exécutable et le stocker dans un fichier de sortie. Selon les options de la compilation, le code généré est .ass pour la machine virtuelle IMA ou bien .class pour la machine virtuelle Java JVM.
    \\
    Nous avons utilisé une instance de la classe \textbf{FileOutputStream} pour stocker le resultat de la compilation dans un fichier de sortie.\\
    Dans le cas où l'option \textbf{JavaCompilation} est activée. Nous utilisons la classe \textbf{JavaCompiler} pour préparer le fichier .class en sortie.

    \subsubsection{JavaCompiler}
    C'est une classe qui a pour rôle de gérer la structure du fichier .class généré. Elle encapsule des attributs de l'API \textbf{ASM} que l'on utilise pour manipuler les fichiers .class de façon haut niveau. \url{https://asm.ow2.io/documentation.html}

\end{document}